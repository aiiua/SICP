#### 1.1.5 过程应用的代换模型

为了求值一个组合式（其运算符是一个复合过程的名字），解释器的工作方式将完全按照组合式求值中所描述，采用予以运算符名为基本过程的组合式一样的计算过程。也就是说，解释器将对组合式的各个元素求值，而后将得到的那个过程（也就是该组合式里运算符的值）应用于那些实际参数（即组合式里那些运算对象的值）。

我们可以假定，把基本运算符引用于实参的机制已经在解释器里做好了，对于复合过程，过程应用的计算过程是：

- 将复合过程应用于实际参数，就是在将过程体中的每个形参用相应的实参取代之后，对这一过程体求值。

为了计算这总计算过程，让我们看看下面组合式的求值:

```lisp
(f 5)
```
其中的f是1.1.4节定义的过程。我们首先提取出`f`的过程体：

```lisp
(sum-of-squares (+ a 1) (* a 2))
```

而后用实际参数`5`代换其中的形式参数：

```lisp
(sum-of-squares (+ 5 1) (* 5 2))
```

这样，问题就被归约为对另一个组合式的求值，其中有两个运算对象，有关的运算符是`sum-of-squares`。求值这一组合式牵涉到三个子问题：

- 我们必须对其中的运算符求值，以便得到应该去应用的那个过程
- 还需要求值两个运算对象，以得到过程的实际参数

这里的`(+ 5 1)`产生`6`，`(* 5 2)`产生`10`，因此我们需要将`sum-of-square`过程用于`6`和`10`。用这两个值代换`sum-of-square`体中的形式参数`x`和`y`，表达式被归约为：

```lisp
(+ (square 6) (square 10))
```

使用`square`的定义又可以将它归约为：

```lisp
(+ (* 6 6) (* 10 10))
```

通过乘法又能将它进一步归约为：

```lisp
(+ 36 100)
```

最后得到：

```lisp
136
```

上面表述的这种计算过程称为过程应用的`代换模型`，在考虑本章至今所定义的过程时，我们可以将它看作过程应用的“意义”的一种模型。但这里还需要强调两点：

- 代换的作用只是为了帮助我们领会过程调用中的情况，而不是对解释器实际工作方式的具体描述。通常的解释器都不采用直接操作过程的正文，用值去代换形式参数的方式去完成对过程调用的求值。在实际中，它们一般采用提供形式参数的局部环境的方式，产生`代换`的效果。
- 代换模型只是`完整的解释器`和`编译器`中的第一个----作为形式化地考虑这种求值过程的起点

##### 应用序和正则序

求值的描述，解释器首先对运算符和各个运算对象求值，而后将得到的过程应用于得到的实际参数。
然而，这并不是执行求值的唯一可能方式。
另一种求值的模型是先不求出运算对象的值，直到实际需要它们的值时再去做。
采用这种求值方式，我们就应该首先用运算对象表达式去代换形式参数，直至得到一个只包含基本运算符的表达式，然后再去执行求值。

如果我们采用这一方式，对下面表达式的求值：

```lisp
(f 5)
```

将按照下面的序列逐步展开：

```lisp
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1) square(* 5 2)))
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)))
```

而后是下面归约：

```lisp
(+ (* 6 6) (* 10 10))
(+ 36 100)

;Value: 136
```

这给出了与前面求值模型同样的结果，但其中的计算过程却是不一样的。
特别地，在对下面表达式的归约中，对于`(+ 5 1)`和`(* 5 2)`的求值各做了两次：

```lisp
(* x x)
```

其中的`x`分别被代换为`(+ 5 1)`和`(* 5 2)`
这种：

- `完全展开而后归约`的求值模型称为`正则序求值`
- `先求值参数而后应用`的方式，称为`应用序求值`

可以证明，对那些可以通过替换去模拟，并能产生出合法的过程应用，正则序和应用序求值将产生同样的就值

Lisp采用应用序求值，部分原因在于这样做能避免对于表达式的重复求值，从而提高一些效率。更重要的是，在超出了采用替换方式模拟的过程范围之后，正则序的处理将变得更复杂得多。